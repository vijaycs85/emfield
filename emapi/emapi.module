<?php
// $Id$

/**
 * @file
 * Provides an API for parsing, storage, and display of third party media.
 */

/* ***************************************** */
/* INCLUDES                                  */
/* ***************************************** */

// A registry of variable_get defaults.
include_once('includes/emapi.variables.inc');

/**
 * Implementation of hook_init().
 */
function emapi_init() {
  emapi_get_provider_classes();

  // Ensure the proper files are loaded when a new media object is initiated.
  spl_autoload_register('emapi_autoload');
}

/**
 * Builds a registry of Media provider classes.
 *
 * Each module supporting a Media provider will need to implement
 * hook_emapi_register, which will need to return an associated array keyed by
 * the scheme, with an array containing at least the following key => value
 * pairs. Note that the scheme portion of the URI this class supports is in the
 * form of scheme://identifier/id.
 *  'class_name' => The actual name of the class.
 * The following key => value pairs are optional, and will otherwise be
 * automatically derived:
 *  'name' => The human-readable name of the scheme.
 *  'description' => A description of the scheme.
 *  'path' => The path where the class file resides.
 *  'file' => The file containing the class definition.
 *  'module' => The module defining the class.
 * The following key => value pair will be automatically set to the association
 * and cannot be overridden:
 *   'scheme' => The scheme portion of the URI.
 *
 * @param string $scheme
 *  (Optional) The scheme of the specific class registration to return.
 * @param boolean $reset
 *  (Optional) If TRUE, then reset the registration.
 * @return array
 *  If $scheme is specified, then return only the specified class array, or NULL
 *  if there is no such registered class. Otherwise, return the entiry registry.
 */
function emapi_get_provider_classes($scheme = NULL, $reset = FALSE) {
  static $emapi_registered_classes;

  if ($reset || !isset($emapi_registered_classes)) {
    $emapi_registered_classes = array();

    // Build our media object class registry.
    foreach (module_implements('emapi_register') as $module) {
      foreach (module_invoke($module, 'emapi_register') as $scheme_name => $class) {
        $emapi_registered_classes[$scheme_name] = is_array($class) ? $class : array();
        $emapi_registered_classes[$scheme_name]['scheme'] = $scheme_name;
        if (!isset($emapi_registered_classes[$scheme_name]['name'])) {
          $emapi_registered_classes[$scheme_name]['name'] = t($scheme_name);
        }
        if (!isset($emapi_registered_classes[$scheme_name]['description'])) {
          $emapi_registered_classes[$scheme_name]['description'] = t('Class definition for @scheme.', array('@scheme' => $scheme_name));
        }
        if (!isset($emapi_registered_classes[$scheme_name]['path'])) {
          $emapi_registered_classes[$scheme_name]['path'] = drupal_get_path('module', $module);
        }
        if (!isset($emapi_registered_classes[$scheme_name]['file'])) {
          $emapi_registered_classes[$scheme_name]['file'] = $class_name .'.inc';
        }
        if (!isset($emapi_registered_classes[$scheme_name]['module'])) {
          $emapi_registered_classes[$scheme_name]['module'] = $module;
        }
      }
    }
  }

  if (isset($scheme)) {
    return $emapi_registered_classes[$scheme];
  }

  return $emapi_registered_classes;
}

/**
 * Autoload the media object classes when needed.
 */
function emapi_autoload($class_name) {
  if ($class_name == 'EmapiMedia') {
    module_load_include('inc', 'emapi', 'includes/emapi.class.media');
  }
  else if ($class = emapi_get_provider_class_by_class_name($class_name)) {
    include_once($class['path'] .'/'. $class['file']);
  }
}

/**
 * Return the registered EmAPI class specified by name.
 */
function emapi_get_provider_class_by_class_name($class_name = NULL, $reset = FALSE) {
  static $classes;

  if (!isset($classes) || $reset) {
    $classes = array();
    $provider_classes = emapi_get_provider_classes();
    foreach ($provider_classes as $scheme => $class) {
      $classes[$class['class_name']] = $class;
    }
  }
  if (isset($class_name)) {
    return $classes[$class_name];
  }
  return $classes;
}

/**
 * Builds and returns a media object based on the parsed URL.
 */
function emapi_media($url, $overrides = array()) {
  global $emapi_registered_classes;

  // First parse the URL.
  foreach ($emapi_registered_classes as $provider => $class) {
    if ($class['parse callback'] && $class['class_name']) {
      if ($parsed = $class['parse callback']($url, $overrides)) {
        // If we have a provider class, then implement and return it.
        return new $class['class_name']($parsed['code'], $overrides);
      }
    }
  }
}

/**
 *  A wrapper around simplexml to retrieve a given XML file.
 *
 *  @param $url
 *    The URL to the XML to retrieve.
 *  @param $display_errors
 *    Optional; if TRUE, then we'll display errors to the end user. They'll be
 *    logged to the watchdog in any case.
 *  @param $refresh
 *    Optional; if TRUE, then we'll force a new load of the XML. Otherwise,
 *    a cached version will be retrieved if possible.
 *  @return
 *    A fully populated object, or FALSE on an error.
 */
function emapi_retrieve_xml($url, $display_errors = FALSE, $refresh = FALSE) {
  module_load_include('inc', 'emapi', 'includes/emapi.xml');
  return _emapi_retrieve_xml($url, $display_errors, $refresh);
}

/**
 * Returns the scheme of a URI (e.g. a stream).
 *
 * Note that this function is lifted from Drupal 7's file_uri_scheme().
 *
 * @param $uri
 *   A stream, referenced as "scheme://target".
 * @return
 *   A string containing the name of the scheme, or FALSE if none. For example,
 *   the URI "youtube://v/3gfh6asey" would return "youtube".
 */
function emapi_uri_scheme($uri) {
  $data = explode('://', $uri, 2);

  return count($data) == 2 ? $data[0] : FALSE;
}

/**
 * Returns the registered class for a specific provider.
 *
 * @param string $uri
 *  A stream, referenced as "scheme://target".
 * @return string
 *  The registered class, or NULL if it's an unsupported URI.
 */
function emapi_get_provider_class($uri) {
  $class = emapi_get_provider_classes(emapi_uri_scheme($uri));
  if (is_array($class) && $class['class_name']) {
    return $class['class_name'];
  }
}

/**
 * Parses a URL or embed code into a media object.
 *
 * @param string $url
 *  The URL or embed code to parse.
 * @return mixed
 *  The fully populated media object, or FALSE.
 */
function emapi_parse($url) {
  foreach (emapi_get_provider_classes() as $class) {
    if (class_exists($class['class_name'])) {
      $media = new $class['class_name'];
      if ($media->parse($url)) {
        return $media;
      }
    }
  }
  return FALSE;
}

/**
 * Loads a media object based on the given URI.
 *
 * @param string $uri
 *  A stream, referenced as "scheme://target".
 * @return mixed
 *  The fully populated media object, or FALSE.
 */
function emapi_media_load($uri) {
  if (($class = emapi_get_provider_class($uri)) && class_exists($class)) {
    $media = new $class($uri);
    return $media;
  }
  return FALSE;
}
