<?php
// $Id$

/**
 * @file
 * Embedded Media Field is a CCK-based framework for embedding media files.
 */

/**
 * Implementation of hook_menu().
 */
function emfield_menu() {
  $items = array();

  // If we require legacy support, then load the old menu items.
  if (emfield_check_for_deprecated_modules()) {
    $items = _emfield_deprecated_menu();
  }

  return $items;
}

/**
 * Implementation of hook_theme().
 */
function emfield_theme($existing, $type, $theme, $path) {
  $themes = array();

  // If we require legacy support, then load the old menu items.
  if (emfield_check_for_deprecated_modules()) {
    $themes = _emfield_deprecated_theme($existing, $type, $theme, $path);
  }

  $themes['emfield_formatter_default'] = array(
    'arguments' => array('element' => NULL),
    'path' => $path .'/includes/themes',
    'file' => 'emfield.themes.inc',
  );

  return $themes;
}

/**
 * Implementation of hook_field_info().
 */
function emfield_field_info() {
  $fields = array(
    'emfield' => array(
      'label' => t('Embedded media'),
      'description' => t('Automatically parse and display embedded media from its URL or embed code.'),
      'callbacks' => array(
        'tables' => CONTENT_CALLBACK_DEFAULT,
        'arguments' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );

  return $fields;
}

/**
 *  Implementation of hook_field_settings().
 */
function emfield_field_settings($op, $field) {
  switch ($op) {
    case 'database columns':
      // Store the URI of the embedded media.
      $columns = array('uri' => array(
          'description' => 'Unique URI for the media.',
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
          'default' => '',
        ),
      );
      return $columns;
  }
}

/**
 * Implementation of hook_content_is_empty().
 */
function emfield_content_is_empty($item, $field) {
  return empty($item['uri']);
}

/**
 * Implementation of hook_field().
 */
function emfield_field($op, &$node, $field, &$items, $teaser, $page) {
  $return = array();
  switch ($op) {
    case 'presave':
      foreach ($items as $delta => $item) {
        // Save the media to the database.
        $item['media'] = emapi_media_from_uri($item['uri']);
        emapi_media_save($item['media']);
      }
      break;
    case 'validate':
      foreach ($items as $delta => $item) {
        if ($field['required'] && !emapi_get_provider_class($item['uri'])) {
          $error_field = $field['multiple'] ? $field['field_name'] .']['. $delta .'][uri' : $field['field_name'];
          form_set_error($error_field, t('You have specified an invalid media URI.'));
        }
      }
      break;
  }
  // Ensure our $op is callable.
  $op = str_replace(' ', '_', $op);
  foreach ($items as $delta => $item) {
    if ($class_name = emapi_get_provider_class($item['uri'])) {
      $class = emapi_get_provider_class_by_class_name($class_name);
      if (module_hook($class['module'], 'emfield_field_'. $op)) {
        $args = array(&$node, $field, &$items, $teaser, $page, $item, $delta);
        $ret = call_user_func_array($class['module'] .'_emfield_field_'. $op, $args);
        if (is_array($ret)) {
          $return = array_merge($return, $ret);
        }
      }
    }
  }
  foreach (module_implements('emfield_field_extra_'. $op) as $module) {
    $args = array(&$node, $field, &$items, $teaser, $page);
    $ret = call_user_func_array($module .'_emfield_field_extra_'. $op, $args);
    if (is_array($ret)) {
      $return = array_merge($return, $ret);
    }
  }
  return $return;
}

/**
 * Implementation of hook_field_formatter_info()
 */
function emfield_field_formatter_info() {
  $types = array('emfield');
  $formats = array(
    'default' => array(
      'label' => t('Default'),
      'field types' => $types,
    ),
  );
  return $formats;
}

/** Widgets **/

/**
 * Implementation of hook_widget_info
 */
function emfield_widget_info() {
  return array(
    'emfield_browser' => array(
      'label' => 'Media browser',
      'field types' => array('emfield'),
      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
        ),
    ),
  );
}

function emfield_widget_settings($op, $widget) {
  switch ($op) {
    case 'form':
      if ($widget['type'] == 'emfield_browser') {
        $form = array();
        $classes = emapi_get_provider_classes();
        foreach ($classes as $class) {
          $options[$class['class_name']] = $class['name'];
        }
        $form['provider_list'] = array(
          '#type' => 'fieldset',
          '#title' => t('Providers Supported'),
          '#description' => t('Select which third party providers you wish to allow for this content type from the list below. If no checkboxes are checked, then all providers will be supported. When a user submits new content, the URL they enter will be matched to the provider, assuming that provider is allowed here.'),
          '#collapsible' => TRUE,
          '#collapsed' => FALSE,
        );
        $form['provider_list']['providers'] = array(
          '#type' => 'checkboxes',
          '#title' => t('Providers'),
          '#default_value' => empty($widget['providers']) ? array() : $widget['providers'],
          '#options' => $options,
        );
      }
      return $form;

    case 'validate':
      break;

    case 'save':
      if ($widget['widget_type'] == 'emfield_browser') {
        $columns = array('providers');
        return $columns;
      }
      break;
  }
}

/**
 * Implementation of hook_widget()
 */
function emfield_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  static $js_added;

  // Our form element will need to be processed as a tree,
  // collapsing any children elements.
  $tree = array('#tree' => TRUE);

  $providers = emfield_allowed_emapi_providers($field);
  $urls = array();
  $additional_form_elements = array();
  foreach ($providers as $provider) {
    $class = emapi_get_provider_class_by_class_name($provider);
    // Grab the provider's URL.
    $urls[] = $class['url'] ? l($class['name'], $class['url'], array('attributes' => array('target' => '_blank'))) : $class['name'];
  }

  // Set the widget description, but allow the field to override this.
  if (!(empty($field['widget']['description']))) {
    $textfield_description = t('!description', array('!description' => content_filter_xss($field['widget']['description'])));
  }
  else {
    $textfield_description = t('Enter the URL or Embed Code here. The embedded third party content will be parsed and displayed appropriately from this.');
  }

  // Add a list of all supported third party providers.
  $textfield_description .= '<br />'. t('The following services are provided: !urls', array('!urls' => implode(', ', $urls)));

  // Get the value of our data, if it's been set for this node.
  $uri = isset($items[$delta]['uri']) ? $items[$delta]['uri'] : '';
  $tree['uri'] = array(
    '#type' => 'textfield',
    '#title' => t('@label', array('@label' => $field['widget']['label'])),
//     '#description' => $textfield_description,
    '#default_value' => $uri,
    '#required' => $delta == 0 ? $field['required'] : FALSE,
    '#maxlength' => 255,
    '#attributes' => array(
      'class' => 'emfield-textfield-uri',
    ),
  );

  $tree['url'] = array(
    '#type' => 'textfield',
    '#title' => t('URL: @TODO launch browser instead.'),
    '#description' => $textfield_description,
    '#maxlength' => 4096,
    '#attributes' => array(
      'class' => 'emfield-textfield-url form-autocomplete',
    ),
  );

  if (!$js_added) {
    $js_added = TRUE;
    drupal_add_js(drupal_get_path('module', 'emfield') .'/includes/js/emfield.widget.js');
    drupal_add_js(array('emfield' => array('parseUrl' => url('emapi/parse/json'))), 'setting');
    drupal_add_css(drupal_get_path('module', 'emfield') .'/includes/themes/css/emfield.widget.css');
  }

  if ($uri) {
    $media = emapi_media_from_uri($uri);
    $class = emapi_get_provider_classes(emapi_uri_scheme($uri));
    if (is_array($class) && $class['name']) {
      $name = $class['name'];
      $url = $media->url();
      $link = l($uri, $url, array('attributes' => array('target' => '_blank')));

      $tree['value_markup'] = array(
        '#type' => 'item',
        '#value' => t('(@provider ID: !value)', array('@provider' => $name, '!value' => $link)),
      );

      $tree['url']['#default_value'] = check_plain($media->url());
    }
  }

  return $tree;
}

/**
 * Return a list of providers allowed for a specific field.
 *
 * @param array $field
 *  (Optional) The field we're checking for providers.
 * @return
 *  If $field is NULL, then return all supported providers. Otherwise, we'll
 *  return the subset of providers allowed by this field.
 */
function emfield_allowed_emapi_providers($field = NULL) {
  $classes = emapi_get_provider_classes();
  $providers = $all_providers = array();
  foreach ($classes as $class) {
    $providers[$class['class_name']] = $all_providers[$class['class_name']] = $class['class_name'];
  }

  $field_providers = isset($field['widget']['providers']) ? $field['widget']['providers'] : (isset($field['providers']) ? $field['providers'] : array());
  foreach ($field_providers as $provider => $allowed) {
    if (!$allowed) {
      unset($providers[$provider]);
    }
  }

  if (!empty($providers)) {
    return $providers;
  }

  return $all_providers;
}

/**
 * Legacy support for deprecated functionality.
 *
 * If we're using a deprecated module, which expects emfield to support version
 * 1 or 2 functionality, then we need to include the legacy functions.
 *
 * @param boolean $reset
 *  If TRUE, then reset our static variable and recheck for the requirement.
 * @return boolean
 *  Return TRUE if we loaded the legacy support.
 */
function emfield_check_for_deprecated_modules($reset = FALSE) {
  static $support_legacy;

  if (!isset($support_legacy) || $reset) {
    $support_legacy = FALSE;
    foreach (array('emvideo', 'emimage', 'emaudio', 'emwave') as $module) {
      if (module_exists($module)) {
        module_load_include('inc', 'emfield', 'deprecated/emfield-deprecated');
        return $support_legacy = TRUE;
      }
    }
  }
  return $support_legacy;
}

// Always check for the requirement of legacy support, until we no longer do @TODO.
emfield_check_for_deprecated_modules();
